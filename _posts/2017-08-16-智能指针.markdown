---
layout: post
title: C++ (OC) å†…å­˜ç®¡ç† & æ™ºèƒ½æŒ‡é’ˆ
date: 2017-08-16 15:59:28.000000000 +09:00
---

## å‰è¨€

ç°åœ¨å¼€å‘çš„é¡¹ç›®ä¸­ç”¨åˆ°äº†å¤§éƒ¨åˆ† `C++` ä»£ç ï¼Œç”±äº `Swift` å’Œ `C++` æ··ç¼–ä¸æ˜¯å¾ˆæ–¹ä¾¿ï¼Œ ä¾ç„¶é€‰æ‹©ç”¨ `OC` æ··ç¼–ï¼Œ åªéœ€è¦å°† `.m `æ–‡ä»¶ ä¿®æ”¹ä¸º `.mm `æ–‡ä»¶å³å¯ã€‚

`OC` é‡Œçš„å¯¹è±¡å¤§éƒ¨åˆ†éƒ½ä¼šåŠ å…¥è‡ªåŠ¨é‡Šæ”¾æ± ä¸­ï¼Œæ‰€ä»¥è¿™äº›éƒ½ä¸ç”¨æ‰‹åŠ¨é‡Šæ”¾ï¼Œä½†æ˜¯ `C++` å¯¹è±¡ä¸ä¼šè¢«åŠ å…¥è‡ªåŠ¨é‡Šæ”¾æ± ,å¿…é¡»è¦æ‰‹åŠ¨é‡Šæ”¾ï¼Œå¦åˆ™ä¼šé€ æˆå†…å­˜æ³„æ¼ã€‚

` .mm `æ–‡ä»¶ä¸­å¯ä»¥éšæ„çš„ `new CppObject()`, ä½†æ˜¯è¦è®°å¾— `delete` ã€‚å½“`cpp`æŒ‡é’ˆè¢«å½“å‰å¯¹è±¡å¼•ç”¨æ—¶ï¼Œå½“å‰å¯¹è±¡çš„` dealloc` æ–¹æ³•é‡Œè¦è®°å¾—é‡Šæ”¾è¯¥èµ„æºã€‚

å€ŸåŠ©è¿™ä¸ªæœºä¼šï¼Œé‡æ¸©ä¸€ä¸‹ `C++`çš„å†…å­˜ç®¡ç† ä»¥åŠ æ™ºèƒ½æŒ‡é’ˆçš„ä½¿ç”¨ã€‚

## æ™®é€šæŒ‡é’ˆ
#### å•ç‹¬çš„å¯¹è±¡
> 
> ```
> ComparePooling* mPool = new ComparePooling();
> // é‡Šæ”¾mPool
> delete mPool;
> ```
> 
> è¿™æ˜¯æœ€ç®€å•çš„ã€‚ã€‚ã€‚

#### é‡Šæ”¾ `C++` æ•°ç»„
> 
> ```
> TestA * aList = new TestA[10];
> // é‡Šæ”¾æ•°ç»„å¯¹è±¡
> delete []aList;
> ```

####  é‡Šæ”¾` vector (stack)`å¯¹è±¡

> ```
> for(vector<MidiPart *>::iterator it = this->mParts.begin(); it != this->mParts.end(); it ++){
>     if (NULL != *it) {
>         delete *it;
>         *it = NULL;
>     }
> }
> this->mParts.clear();
> ```

####  ç°åœ¨è€ƒè™‘ä¸‹é¢æƒ…å†µ

> ```
> void func()
> {
>     int *p = new int(5);
> 	  do something...
>     throw "exception occured";
>     delete p;
> }
> int main(){
>     try {
>         func();
>     } catch (const char* str) {
>         std::cout<<str <<std:endl;
>     }
> }
> ```
> 
> `func `å‡½æ•° ä¸­ å¯èƒ½ä¼šè§¦å‘å¼‚å¸¸ï¼Œæ˜¯å‡½æ•°æå‰é€€å‡ºï¼Œè¿™æ ·æœ‰å¯èƒ½èµ„æºä¸ä¼šå¾—åˆ°é‡Šæ”¾ã€‚æœ‰æ•ˆä½¿ç”¨ æ™ºèƒ½æŒ‡é’ˆ å¯ä»¥è§£å†³è¿™ä¸€é—®é¢˜ã€‚
## æ™ºèƒ½æŒ‡é’ˆ

æ™ºèƒ½æŒ‡é’ˆçš„åŸç†å°±æ˜¯å°†ä½  `new` å‡ºæ¥çš„ä¸€ä¸ªæŒ‡é’ˆ`ptr`ä¼ ç»™ä»–ï¼Œå®ƒè¿”å›ä¸€ä¸ªæ ˆä¸Šçš„å¯¹è±¡ `A` ç»™ä½ ã€‚è¿™ä¸ªå¯¹è±¡ä¿å­˜ç€ä½ ä¼ å…¥çš„ `ptr `ã€‚ å½“ `A` ç¦»å¼€ä½œç”¨åŸŸï¼ˆæ— è®ºæ˜¯å‘½åç©ºé—´è¿˜æ˜¯å‡½æ•°ï¼Œè¿˜æ˜¯æŠ›å‡ºå¼‚å¸¸æå‰é€€å‡ºï¼‰ï¼Œ A çš„ææ„å‡½æ•°éƒ½ä¼šè¢«è°ƒç”¨ï¼Œææ„å‡½æ•°å†…éƒ¨ä¼š é‡Šæ”¾` ptr `æŒ‡é’ˆã€‚æ‰€ä»¥ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆä¼šä¸ºèµ„æºç®¡ç†æä¾›æ–¹ä¾¿ã€‚ 

### `auto_ptr`

```
class ObjectA {
    public:
    ~ObjectA(){
        std::cout<<"TestA did release"<<std::endl;
    }
    ObjectA(int age): mAge(age) {}
    int mAge;
};
int main(int argc, const char * argv[]) {
    // insert code here...
    std::auto_ptr<ObjectA> ptr_a( new ObjectA(20) );
    std::cout<< ptr_a->mAge << std::endl;
    return 0;
}
```
`outPut `å¦‚ä¸‹
```
20
TestA did release
```

è‹¥è¦æ‰‹åŠ¨é‡Šæ”¾å¯ä»¥è°ƒç”¨ `reset()` å‡½æ•°

```
int main(int argc, const char * argv[]) {
    std::auto_ptr<ObjectA> ptr_a( new ObjectA(20) );
	  ptr_a.reset();
    std::cout<< ptr_a->mAge << std::endl; // Crash !!!
    return 0;
}
```

å¯¹è±¡å·²è¢«é‡Šæ”¾ï¼Œå†æ¬¡è®¿é—®å°±ä¼šå˜æˆé‡æŒ‡é’ˆï¼Œç¨‹åºä¼šå´©æºƒã€‚
å½“`reset()` æ–¹æ³•ä¼ å…¥å‚æ•°æ—¶ä¼šæ›¿æ¢æ‰å†…éƒ¨ä¿æŒçš„æŒ‡é’ˆ

```
int main(int argc, const char * argv[]) {
    std::auto_ptr<ObjectA> ptr_a( new ObjectA(20) );
	  ptr_a.reset(new ObjectA(40));
    std::cout<< ptr_a->mAge << std::endl; // outPut : 40
    return 0;
}
```

å¦å¤– auto_ptr ä¸èƒ½æŒ‡å‘ä¸€ä¸ªæ•°ç»„å¯¹è±¡ï¼Œä¼šç›´æ¥`crash`ã€‚å› ä¸ºå®ƒå†…éƒ¨ ä½¿ç”¨çš„ `delete ptr` , è€Œä¸æ˜¯ `delete[] ptr `ã€‚

### `shared_ptr`

`shared_ptr` æœ‰ä¸€ç§å…±äº«æ‰€æœ‰æƒçš„æ¦‚å¿µï¼Œn ä¸ªæŒ‡é’ˆå¯ä»¥åŒæ—¶æŒ‡å‘ä¸€ä¸ªå¯¹è±¡ï¼Œè¿™ä¸ªå¯¹è±¡çš„å¼•ç”¨è®¡æ•°å°±ä¸º nï¼ŒçŸ¥é“æœ€åä¸€ä¸ªå¯¹è±¡ç¦»å¼€ä½œç”¨åŸŸæ—¶æ‰ä¼šé‡Šæ”¾è¯¥å¯¹è±¡ ã€‚æ‰€ä»¥å½“æˆ‘ç¬¬ä¸€æ¬¡æ¥è§¦ `iOS` çš„ `ARC`  æœºåˆ¶ä¸­çš„å¼ºå¼•ç”¨(`strong`)æ—¶ï¼Œæ„Ÿè§‰å¦‚æ­¤ç†Ÿæ‚‰ã€‚

```
int main(){
    {
        std::cout << "constructor with no managed object\n";
        std::shared_ptr<ObjectA> sh1;
    }
    {
        std::cout << "constructor with object\n";
        std::shared_ptr<ObjectA> sh2(new ObjectA);
        std::shared_ptr<ObjectA> sh3(sh2);
        std::cout << sh2.use_count() << '\n';
        std::cout << sh3.use_count() << '\n';
    }
    {
        std::cout << "constructor with object and deleter\n";
        std::shared_ptr<ObjectA> sh5(new ObjectA, [](auto p) {
            std::cout << "Call delete from lambda...\n";
            delete p;
        });
    }
}
```

`outPut` å¦‚ä¸‹

```
constructor with no managed object
constructor with object
2
2
ObjectA did release
constructor with object and deleter
Call delete from lambda...
ObjectA did release
```

`shared_ptr` çš„æ„é€ å‡½æ•° å¯ä»¥ç”¨ä¸€ä¸ª`deleter` (`lambada` è¡¨è¾¾å¼) ä½œä¸ºå‚æ•°

```
template< class Y, class Deleter > shared_ptr( Y* ptr, Deleter d );
std::shared_ptr<ObjectA> sh5(new ObjectA, [](auto p) {
            std::cout << "Call delete from lambda...\n";
            delete p;
        });
```

é‚£ä¹ˆæˆ‘ä»¬æƒ³ä¼ å…¥ä¸€ä¸ªæ•°ç»„å¯¹è±¡æ—¶å°±å¯ä»¥å¦‚ä¸‹æ“ä½œ

```
std::shared_ptr<ObjectA> sh5(new ObjectA, [](auto p) {
            delete[] p;
        });
```

### å¾ªç¯å¼•ç”¨

å°†`shared_ptr` éšæ„å¼ºå¼•ç”¨ç»™å…¶ä»–å¯¹è±¡ï¼Œå¯èƒ½ä¼šé€ æˆå¾ªç¯å¼•ç”¨

```
#include <iostream>
class ObjectB;
class ObjectA {
    public:
    ~ObjectA(){
        std::cout<<"ObjectA did release"<<std::endl;
    }
    ObjectA() {}
    std::shared_ptr<ObjectB> mPtrB;
};
class ObjectB {
public:
    ~ObjectB(){
        std::cout<<"ObjectB did release"<<std::endl;
    }
    ObjectB() {}
    std::shared_ptr<ObjectA> mPtrA;
};
int main(){
    {
        std::shared_ptr<ObjectA> ptr_a (new ObjectA);
        std::shared_ptr<ObjectB> ptr_b (new ObjectB);
        ptr_a->mPtrB = ptr_b;
        ptr_b->mPtrA = ptr_a;
    }
}
```

ä¸Šé¢çš„ `ObjectA`  å’Œ `ObjectB` éƒ½ä¸ä¼šè¢«é‡Šæ”¾.  

` ObjectA -> ptr_b -> ObjectB -> ptr_a -> ObjectA `

é€ æˆäº†å¾ªç¯å¼•ç”¨ï¼Œæ‰€ä»¥ä¸ºäº†è§£å†³è¿™ä¸€é—®é¢˜ï¼Œ C++ æä¾›äº† å¼±æŒ‡é’ˆ å¦‚ä¸‹ã€‚

### `weak_ptr`

`weak_ptr` æ˜¯å¯¹æºå¯¹è±¡çš„å¼±å¼•ç”¨ï¼Œ`weak_ptr` æŒ‡å‘è¯¥å¯¹è±¡æ˜¯ï¼Œè¯¥å¯¹è±¡çš„ å¼•ç”¨è®¡æ•°ä¸ä¼šåŠ ä¸€ã€‚
`weak_ptr`  çš„åˆ›å»ºä¸€èˆ¬ç”¨ä¸€ä¸ª`shared_ptr` å¯¹è±¡ ä½œä¸ºå‚æ•°ã€‚

```
void main( ){
 shared_ptr<ObjectA> sptr( new ObjectA );
 weak_ptr<ObjectA> wptr( sptr );
 weak_ptr<ObjectA> wptr1 = wptr;
}
```

å½“ `shared_ptr` ç¦»å¼€äº†è‡ªå·±çš„å®šä¹‰åŸŸåï¼Œ`shared_ptr` è¢«é‡Šæ”¾ã€‚`weak_ptr` æŒ‡å‘çš„å¯¹è±¡ä¹Ÿå°±é‡Šæ”¾äº†ï¼Œ`weak_ptr` å¯¹è±¡çš„å¼•ç”¨è®¡æ•°ä¸º 0ã€‚

```
void main(){
    std::weak_ptr<ObjectA> w_ptr;
    {
        std::shared_ptr<ObjectA> ptr(new ObjectA);
        w_ptr = ptr;
        std::cout << "w_ptr.use_count() inside scope: " << w_ptr.use_count() << '\n';
    }
    std::cout << "w_ptr.use_count() out of scope: " << w_ptr.use_count() << '\n';
    std::cout << "w_ptr.expired() out of scope: " << std::boolalpha << w_ptr.expired() << '\n';
}
```

`outPut` å¦‚ä¸‹

```
w_ptr.use_count() inside scope: 1
ObjectA did release
w_ptr.use_count() out of scope: 0
w_ptr.expired() out of scope: true
```

### `unique_ptr`

`unique_ptr` å’Œ `auto_ptr` ç±»ä¼¼ã€‚åœ¨ä»»ä½•æ—¶é—´ç‚¹ï¼Œå¯¹è±¡åªèƒ½è¢«ä¸€ä¸ª `unique_ptr` æ‰€æŒæœ‰ã€‚`unique_ptr` ä¸æ”¯æŒæ™®é€šçš„æ‹·è´å’Œèµ‹å€¼æ“ä½œã€‚

```
void main() 
{
    // åˆ›å»ºä¸€ä¸ªunique_ptrå®ä¾‹
    unique_ptr<int> pInt(new int(5));
    unique_ptr<int> pInt2(pInt);    // æŠ¥é”™
    unique_ptr<int> pInt3 = pInt;   // æŠ¥é”™
}
```

`unique_ptr`è™½ç„¶æ²¡æœ‰æ”¯æŒæ™®é€šçš„æ‹·è´å’Œèµ‹å€¼æ“ä½œï¼Œä½†å´æä¾›äº†ä¸€ç§ç§»åŠ¨æœºåˆ¶æ¥å°†æŒ‡é’ˆçš„æ‰€æœ‰æƒä»ä¸€ä¸ª`unique_ptr`è½¬ç§»ç»™å¦ä¸€ä¸ª`unique_ptr`ã€‚å¦‚æœéœ€è¦è½¬ç§»æ‰€æœ‰æƒï¼Œå¯ä»¥ä½¿ç”¨`std::move()`å‡½æ•°ã€‚

```
void main() 
{
    unique_ptr<int> pInt(new int(5));
    unique_ptr<int> pInt2 = std::move(pInt);    // è½¬ç§»æ‰€æœ‰æƒ
    //cout << *pInt << endl; // å‡ºé”™ï¼ŒpIntä¸ºç©º
    cout << *pInt2 << endl;
    unique_ptr<int> pInt3(std::move(pInt2));
}
```

ä¸‹é¢çœ‹ä¸ªğŸŒ°å­

```
#include <iostream>
#include <vector>
#include <memory>
#include <cstdio>
#include <cassert>
#include <functional>
 
struct B {
  virtual void bar() { std::cout << "B::bar\n"; }
  virtual ~B() = default;
};
struct D : B
{
    D() { std::cout << "D::D\n";  }
    ~D() { std::cout << "D::~D\n";  }
    void bar() override { std::cout << "D::bar\n";  }
};
 
// a function consuming a unique_ptr can take it by value or by rvalue reference
std::unique_ptr<D> pass_through(std::unique_ptr<D> p)
{
    p->bar();
    return p;
}
 
int main()
{
  std::cout << "unique ownership semantics demo\n";
  {
      auto p = std::make_unique<D>(); // p is a unique_ptr that owns a D
      auto q = pass_through(std::move(p)); 
      assert(!p); // now p owns nothing and holds a null pointer
      q->bar();   // and q owns the D object
  } // ~D called here
 
  std::cout << "Runtime polymorphism demo\n";
  {
    std::unique_ptr<B> p = std::make_unique<D>(); // p is a unique_ptr that owns a D
                                                  // as a pointer to base
    p->bar(); // virtual dispatch
 
    std::vector<std::unique_ptr<B>> v;  // unique_ptr can be stored in a container
    v.push_back(std::make_unique<D>());
    v.push_back(std::move(p));
    v.emplace_back(new D);
    for(auto& p: v) p->bar(); // virtual dispatch
  } // ~D called 3 times
 
  std::cout << "Custom lambda-expression deleter demo\n";
  {
    std::unique_ptr<D, std::function<void(D*)>> p(new D, [](D* ptr)
        {
            std::cout << "destroying from a custom deleter...\n";
            delete ptr;
        });  // p owns D
    p->bar();
  } // the lambda above is called and D is destroyed
 
  std::cout << "Array form of unique_ptr demo\n";
  {
      std::unique_ptr<D[]> p{new D[3]};
  } // calls ~D 3 times
}
```

Output:

```
unique ownership semantics demo
D::D
D::bar
D::bar
D::~D
Runtime polymorphism demo
D::D
D::bar
D::D
D::D
D::bar
D::bar
D::bar
D::~D
D::~D
D::~D
Custom lambda-expression deleter demo
D::D
D::bar
destroying from a custom deleter...
D::~D
Array form of unique_ptr demo
D::D
D::D
D::D
D::~D
D::~D
D::~D
```

æ€»ç»“
å®é™…`coding`ä¸­ï¼Œè¿˜æ˜¯`shared_ptr` ä½¿ç”¨çš„å¤šã€‚ä»£ç ä¸­é¿å…ä¸äº†å°†å¯¹è±¡èµ‹å€¼ç»™å…¶ä»–å¯¹è±¡ã€‚